program Aufgabe7;
{Apptype console}
{$R+,Q+,X-}

uses
  SysUtils, Math, Crt;

const 
  COLS = 10;
  ROWS = 12;
  OFFSET_COL : array[0..3] of integer = (0, 1, 0, -1); // up, right, down, left
  OFFSET_ROW : array[0..3] of integer = (-1, 0, 1, 0);
  FIELD_10x12 : string = 'KKKKKKKKKKKKKWWWWWKKKWWWEEEWKKKWTSBEEWKKKWWWEBTWKKKWTWWBEWKKKWEWETEWWKKWBEXBBTWKKWEEETEEWKKWWWWWWWWKKKKKKKKKKKKKKKKKKKKK'; 

type
  State = (StateEmpty, StateWall, StateBox, StateTarget, StateSokoban, StateBoxOnTarget,StateBackground, StateSokobanOnTarget);
  TWidth = 1..COLS;
  THeight = 1..ROWS;
  TField = array[TWidth, THeight] of State;
  TDir = (up, right, down, left);


function IsValidCord(col, row: Integer): Boolean;
begin
 isValidCoord := (col >= low(TWidth)) and (col <= high(TWidth)) and
                  (row >= low(THeight)) and (row <= high(THeight));
end;

function InitField : TField;
var
  field : TField;
  stringIndex: integer;
  col, row: integer;
  currentChar: char;

begin
 stringIndex := 1;
 for row := low(THeight) to high(THeight) do
 begin
  if stringIndex <= Length(FIELD_10x12) then
    begin
    currentChar := Field_10x12[stringIndex];
    case currentChar of
      'K' : field [row, col] := StateBackground; // Sokoban
      'W' : field [row, col] := StateWall; // Wall 
      'B' : field [row, col] := StateBox; // Box
      'E' : field [row, col] := StateEmpty; // Empty
      'T' : field [row, col] := StateTarget; // Target
      'X' : field [row, col] := StateBoxOnTarget; // Box on Target
      'S' : field [row, col] := StateSokoban; // Sokoban
      'O' : field [row, col] := StateSokobanOnTarget; // Sokoban on Target
      else field[row, col] := StateEmpty;
      end;
    end
    else
    field[row, col] := StateEmpty; // Default to empty if no match

    inc(stringIndex);
    end;
    InitField := field;

end;

procedure PrintField(Field: TField);
var
  cols, rows: TWidth;
begin
    setPosition(1, 2); // Ab der zweiten Zeile ausgeben

    for rows := low(THeight) to high(THeight) do
    begin
        for cols := low(TWidth) to high(TWidth) do
        begin
            case Field[cols, rows] of
                StateEmpty:
                begin
                TextColor := White;
                write('░'); // empty 
                end;
                StateWall:
                begin
                TextColor := LightGrey;
                write('░'); // Wand
                end;
                StateBox:
                begin
                TextColor := Yellow;
                write('░'); // Box
                end;
                StateTarget:
                begin
                TextColor := LightGreen;
                write('o'); // Zielfeld 
                end;
                StateSokoban:
                begin
                TextColor := Red;
                write('░'); // Spieler aka Sokoban
                end;
                StateBoxOnTarget:
                begin
                TextColor := LightGreen;
                write('░'); // Box auf Zielfeld
                end;
                StateBackground:
                begin
                TextColor := Black;
                write('░'); // Hintergrund 
                end;
                StateSokobanOnTarget:
                begin
                TextColor := DarkGreen;
                write('░');
                end;

        end;
        end;  


end;

procedure MoveSokoban(var Field: TField; dir : TDir; var steps, moves: byte);

begin
found := false;

end;

procedure SetConsolePosition(x, y: byte);
begin
end;

function IsSolvable(field: TField): Boolean;
var
  col, row: integer;
  boxCount, targetCount: integer;
  hasBoxInCorner, hasTargetAccessible: boolean;
  solvable: boolean;
begin
  boxCount := 0;
  targetCount := 0;
  hasBoxInCorner := false;
  hasTargetAccessible := true;
  solvable := true;
  
  // Zähle Boxen und Targets
  for row := low(THeight) to high(THeight) do
  begin
    for col := low(TWidth) to high(TWidth) do
    begin
      case field[col, row] of
        StateBox, StateBoxOnTarget: inc(boxCount);
        StateTarget, StateBoxOnTarget, StateSokobanOnTarget: inc(targetCount);
      end;
    end;
  end;
  
  // Prüfe ob Anzahl Boxen = Anzahl Targets
  if boxCount <> targetCount then
    solvable := false;
  
  // Prüfe auf Boxen in Ecken (die nicht auf Targets stehen)
  if solvable then
  begin
    for row := low(THeight) to high(THeight) do
    begin
      for col := low(TWidth) to high(TWidth) do
      begin
        if field[col, row] = StateBox then
        begin
          // Prüfe ob Box in Ecke steht
          if IsValidCord(col-1, row) and IsValidCord(col, row-1) and
             IsValidCord(col+1, row) and IsValidCord(col, row+1) then
          begin
            // Ecke oben-links
            if (field[col-1, row] = StateWall) and (field[col, row-1] = StateWall) then
              hasBoxInCorner := true;
            // Ecke oben-rechts  
            if (field[col+1, row] = StateWall) and (field[col, row-1] = StateWall) then
              hasBoxInCorner := true;
            // Ecke unten-links
            if (field[col-1, row] = StateWall) and (field[col, row+1] = StateWall) then
              hasBoxInCorner := true;
            // Ecke unten-rechts
            if (field[col+1, row] = StateWall) and (field[col, row+1] = StateWall) then
              hasBoxInCorner := true;
          end;
        end;
      end;
    end;
    
    if hasBoxInCorner then
      solvable := false;
  end;
  
  IsSolvable := solvable;
end;

function isSolved(field : TField) : boolean;
var

  col, row: TWidth;
  boxCount, targetCount: integer; 
begin
  boxCount := 0;
  targetCount := 0;

  for row := low(THeight) to high(THeight) do
  begin
    for col := low(TWidth) to high(TWidth) do
    begin
      case Field[col, row] of
        StateBox, StateBoxOnTarget: inc(boxCount);
        StateTarget, StateSokobanOnTarget: inc(targetCount);
      end;
    end;
  end;

  isSolved := (boxCount = targetCount) and (targetCount > 0); 
end;
var
 input: char;
begin
 if 

  // Hauptprogrammcode hier
end.
